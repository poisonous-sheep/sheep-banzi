# äºŒç»´æ•°ç‚¹ (Offline 2D Range Counting) ğŸš€

è¿™æ˜¯ä¸€ä¸ªåŸºäº **æ‰«æçº¿ (Sweep Line)** å’Œ **æ ‘çŠ¶æ•°ç»„ (Binary Indexed Tree)** å®ç°çš„ç¦»çº¿äºŒç»´æ•°ç‚¹ç®—æ³•æ¨¡æ¿ã€‚å¸¸ç”¨äºè§£å†³â€œç»™å®šå¹³é¢ä¸Šè‹¥å¹²ç‚¹ï¼ŒæŸ¥è¯¢çŸ©å½¢åŒºåŸŸå†…ç‚¹æ•°â€çš„é—®é¢˜ã€‚

### 1. ç»´åº¦è½¬æ¢ (2D  1D)

ç›´æ¥å¤„ç†äºŒç»´åŒºé—´æŸ¥è¯¢å¤æ‚åº¦è¾ƒé«˜ã€‚æœ¬ç®—æ³•é€šè¿‡**ç¦»çº¿ (Offline)** å¤„ç†ï¼Œå°†äºŒç»´é—®é¢˜è½¬åŒ–ä¸ºä¸€ç»´åŠ¨æ€ç»´æŠ¤ï¼š

* **çºµå‘ (Yè½´)**ï¼šåˆ©ç”¨æ‰«æçº¿æ€æƒ³ï¼Œå°†æ‰€æœ‰ç‚¹å’ŒæŸ¥è¯¢è¾¹ç•ŒæŒ‰  åæ ‡æ’åºï¼ŒæŒ‰é¡ºåºâ€œæ‰«æâ€ã€‚
* **æ¨ªå‘ (Xè½´)**ï¼šåœ¨æ‰«æè¿‡ç¨‹ä¸­ï¼Œä½¿ç”¨æ ‘çŠ¶æ•°ç»„åŠ¨æ€ç»´æŠ¤å½“å‰é«˜åº¦ä¸‹  åæ ‡çš„å‡ºç°æ¬¡æ•°ã€‚

### 2. å®¹æ–¥åŸç† (Inclusion-Exclusion)

å¯¹äºçŸ©å½¢æŸ¥è¯¢ ï¼Œæˆ‘ä»¬åˆ©ç”¨å‰ç¼€å’Œæ€æƒ³å°†å…¶æ‹†è§£ä¸ºå››ä¸ªå‰ç¼€çŸ©å½¢æŸ¥è¯¢ï¼š



å…¶ä¸­  è¡¨ç¤ºå·¦ä¸‹è§’ä¸º ï¼Œå³ä¸Šè§’ä¸º  çš„çŸ©å½¢å†…çš„ç‚¹æ•°ã€‚

---

## ğŸ› ï¸ å®ç°ç»†èŠ‚

### äº‹ä»¶æ‹†è§£

æ¯ä¸ªæŸ¥è¯¢è¢«æ‹†åˆ†ä¸º 4 ä¸ªäº‹ä»¶ï¼Œå­˜å…¥ `event` æ•°ç»„ï¼š

* `{y, type, x, id}`
* `type = 0`: è¡¨ç¤ºç‚¹ï¼ˆæ›´æ–°æ“ä½œï¼‰ã€‚
* `type = 1`: è¡¨ç¤ºæƒé‡ä¸º  çš„æŸ¥è¯¢ã€‚
* `type = 2`: è¡¨ç¤ºæƒé‡ä¸º  çš„æŸ¥è¯¢ã€‚

### æ’åºä¼˜å…ˆçº§

æ’åºæ—¶ï¼Œè‹¥  ç›¸åŒï¼Œ**ç‚¹äº‹ä»¶ (è¾“å…¥=0) ä¼˜å…ˆäºæŸ¥è¯¢äº‹ä»¶ (è¾“å…¥=1/2)**ã€‚è¿™æ ·å¯ä»¥ç¡®ä¿ä½äºçŸ©å½¢è¾¹ç•Œä¸Šçš„ç‚¹ä¹Ÿèƒ½è¢«æ­£ç¡®ç»Ÿè®¡ã€‚

---

## ğŸ’» æ ¸å¿ƒä»£ç å®ç°

```cpp
/**
 * äºŒç»´æ•°ç‚¹æ ¸å¿ƒé€»è¾‘
 * rx: ç¦»æ•£åŒ–åçš„xåæ ‡æ•°ç»„
 * event: å­˜å‚¨ç‚¹å’ŒæŸ¥è¯¢æ‹†åˆ†åçš„äº‹ä»¶ {y, type, x, id}
 */
void solve() {
    int n, q;
    cin >> n >> q;
    vector<int> rx;
    vector<array<int, 4>> event;

    // 1. è¯»å…¥ç‚¹å¹¶é¢„å¤‡ç¦»æ•£åŒ–
    rep(1ï¼Œ n) {
        int x, y;
        cin >> x >> y;
        event.push_back({yï¼Œ 0ï¼Œ x, i}); // è¾“å…¥ 0: ç‚¹
        rx.push_back(x);
    }
    sort(rxã€‚begin()ï¼Œ rx.end());
    rx.erase(unique(rx.begin()ï¼Œ rx.end())ï¼Œ rx.end());

    // 2. æ‹†åˆ†æŸ¥è¯¢ (å®¹æ–¥åŸç†)
    vector<ll> ans(q + 1, 0);
    rep(1ï¼Œ q) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        // æ‹†åˆ†ä¸ºå››ä¸ªå‰ç¼€çŸ©å½¢æŸ¥è¯¢ç‚¹
        event.push_back({y2ï¼Œ 1ï¼Œ x2, i});           // +S(x2, y2)
        event.push_back({y2ï¼Œ 2ï¼Œ x1 - 1ï¼Œ i});       // -S(x1-1, y2)
        event.push_back({y1 - 1, 2ï¼Œ x2, i});       // -S(x2, y1-1)
        event.push_back({y1 - 1, 1ï¼Œ x1 - 1ï¼Œ i});   // +S(x1-1, y1-1)
    }

    // 3. æ’åº (yå‡åº, åŒyåˆ™type=0ä¼˜å…ˆ)
    sort(event.begin()ï¼Œ event.end());

    // 4. æ‰«æçº¿æ‰§è¡Œ
    BIT<ll> bit(rx.size() + 5);
    for (auto &env : event) {
        if (env[1] == 0) { // åŠ ç‚¹
            int id = lower_bound(rxã€‚begin()ï¼Œ rx.end()ï¼Œ env[2]) - rx.begin() + 1;
            bit.add(id, 1);
        } else { // æŸ¥è¯¢
            // æ‰¾åˆ° rx ä¸­æœ€åä¸€ä¸ª <= env[2] çš„ç´¢å¼•
            int id = upper_bound(rxã€‚begin()ï¼Œ rx.end()ï¼Œ env[2]) - rx.begin();
            if (env[1] == 1) ans[env[3]] += bit.sum(id);
            else ans[env[3]] -= bit.sum(id);
        }
    }

    // 5. è¾“å‡ºç­”æ¡ˆ
    rep(1ï¼Œ q) cout << ans[i] << endl;
}

```
