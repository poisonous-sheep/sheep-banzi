## 并查集(DSU)

### 就是合并，查找（集合）

### 朴素并查集
通过直接让自己的父节点直接指向祖宗节点来实现。

如何实现？通过路径压缩。

 ![alt text](7ba71d2c23d63651224517b931fd72e4.jpg)



 ``` cpp c++
 int fid[N];

 int root(int x){
    if(x!=fid[x]) fid[x]=root(fid[x]);//不断找自己的父亲节点，直到找到根节点
    //1->2,2->3,3->4,4->4。
    return fid[x];
 }

 void merge(int x,int y){
    x=root(x);y=root(y);
    if(x!=y) fid[x] = y;//自身合并到y上
 }//添加

 ```




#### [例题hdu1213](https://acm.hdu.edu.cn/showproblem.php?pid=1213)

##### 题目大意 

一共有n个人，m队朋友，朋友能和朋友在一桌吃饭，求最少的桌子。

##### 题解

就是并查集的板子题，丢到并查集看看有多少集合就可以

##### code:
``` cpp c++
#include<bits/stdc++.h>

using namespace std;

const int N =2e5+10;

int fid[N];
int root(int x){
    if(x!=fid[x]) fid[x]=root(fid[x]);
    return fid[x];
}

void merge(int x,int y){
    x=root(x);y=root(y);
    if(x!=y) fid[x] = y ;
}

void solve(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)fid[i]=i;
    while (m--)
    {
        int x,y;cin>>x>>y;
        merge(x,y);
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        if(root(i)==i)ans++;
    }
    cout<<ans<<endl;
    
}

int main(){
    ios::sync_with_stdio(0);
    cout.tie(0);
    int t=1;
    cin>>t;
    while(t--)solve();
    return 0;
}
```

### 带权并查集

所谓带权并查集，就是路径压缩的时候把自身的权值给根节点。
(相加，相乘，异或，|=(or))

我们以相加为例子：
![alt text](1e9aabdd690ef7d9a3a6fa607d9aefee.jpg)

此时的$4$就是 $1,2,3,4$ 的权值总和。我们考虑用一个数组维护。
a[x] 表示 从节点 x 到根节点的路径上的所有边的权值总和
从$a[x]->a[根基点]$的距离.
比如上图的$a[1]->a[4]$. a[1]代表是从1->4的权值和:$a[1]+a[2]+a[3].$
一般根节点的权值和为0.

``` cpp c++
int root(int x){
    if(x!=fid[x]){
        int t =fid[x];
        fid[x] =root(fid[x]);
        a[x]+=a[t];
    }
    return fid[x];
}
```

#### [例题hdu3080](https://acm.hdu.edu.cn/showproblem.php?pid=3038)

##### 题目大意：

先给出$[a,b]$区间和为$v$，进行$x$次查询，每次检查是否冲突，最后输出冲突的个数。（注意是按顺序来的）

#### 题解

那么我们就可以利用带权并查集进行进行建树，fid[x]代表了节点x的父亲节点，而val[x]代表了sum[x] - sum[par[x]]；

首先是find()函数，我们在原来最基础的并查集find函数中，是有一种类似于把x的父亲节点par[x]变成par[par[x]]这样的，将节点沿着树枝往上移动的操作，

那么相应的，我们每次做将par[x]变成par[par[x]]这样的操作时，val[x]也要修改为val[x]+val[par[x]]；

其次，我们对于每次查询的结果a,b,s，令 t1 = find(a)，t2 = find(b)，那么对应的s,val[a],val[b],val[t2]就可以如下图的向量所示：
![alt text](image.png)

``` cpp c++
#include <bits/stdc++.h>
using namespace std;

#define rep(l, r) for (int i = l; i <= r; i++)

const int N = 2e5 + 10;

int fid[N];
int a[N];
int n, m;
int ans;

int root(int x)
{
    if (x != fid[x])
    {
        int t = fid[x];
        fid[x] = root(fid[x]);
        a[x] += a[t]; // 更新权值差
    }
    return fid[x];
}

void merge(int x, int y, int z)
{
    int rotx = root(x);
    int roty = root(y);
    if (rotx == roty)
    { // 如果两个节点已经在同一个集合中
        if (a[x] - a[y] != z)
            ans++; // 检查权值差是否满足条件
    }
    else
    {
        fid[rotx] = roty;
        a[rotx] = a[y] - a[x] + z; // 更新权值差
    }
}


int main()
{
     while (scanf("%d%d", &n, &m) != EOF)
    {
        ans = 0;
        rep(0, N) fid[i] = i, a[i] = 0;
        rep(1, m)
        {
            int x, y, z;
            cin >> x >> y >> z;
            x--;
            merge(x, y, z);
        }
        cout << ans << endl;
    }
}

```