## 分块的应用
**可以干什么**：我们可以干一些形如：
$$\sum_{i=1}^{n}{f(i)g(\lfloor \frac{n}{i} \rfloor)}$$
的公式的计算。**要求有**
- O(1)计算出$\sum_{i=l}^{r}{f(i)}$或者预处理了$f(i)$ 的前缀和。
如果满足以上要求，我们就可以把$O(n)$的复杂度降低成$O(\sqrt{n})$ 

## 为什么可以降低：
比如这个例子来说$$\sum_{i=1}^{n}{\lfloor \frac{n}{i} \rfloor}$$
这个例子是上面公式的特殊化处理，他的$f(i)=1,g(i)=i$
我们以$n=11$来举例子：我们发现当$i$的增加，我们的值变化的越来越慢。只能分成四块，
我们就可以把**每一块的** 的**个数相乘** 一次只算一块，我们只需要要算$O(\sqrt{n})$ 的复杂度就可以解决这个问题。

![[Pasted image 20250929111257.png]]


## 原理证明：

比如这个式子来说，他的右端点是每次的$\lfloor \frac{n}{\lfloor \frac{n}{i} \rfloor} \rfloor$ 为什么：
![[Pasted image 20251001130435.png]] 
把$d=\lfloor \frac{n}{i} \rfloor$代入得到$R=\lfloor \frac{n}{\lfloor \frac{n}{i} \rfloor} \rfloor$ 
因此我们的R和L都确定我们可以通过：$R-L+1$算出一段的长度因此我们就要可以做了

## code实现：

[板子题]([UVA11526 H(n) - 洛谷](https://www.luogu.com.cn/problem/UVA11526))
``` cpp c++
void solve()

{

    int n;

    cin>>n;

    int ans=0;

    for(int l=1,r=1;l<=n;l=r+1){

        r=n/(n/l);

        int res=n/l;

        ans+=res*(r-l+1);

    }

    cout<<ans<<endl;

}
```

