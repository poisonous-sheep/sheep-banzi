# 根号分治 (Square Root Decomposition) 🧊

根号分治是一种通过将数据规模或处理方式分为“大”和“小”两部分，从而平衡修改和查询复杂度的算法思想。通常取 $B \approx \sqrt{N}$ 作为分界点 。

## 1. 核心思想 (The Balance) ⚖️

根号分治并非某种特定算法，而是一种根据不同问题分情况讨论的策略 。其核心在于：

- **小规模处理**：对于出现频率高但单次规模小的操作，采用预处理或打标记的方式 。
    
- **大规模处理**：对于规模大但出现次数有限的操作，采用暴力遍历的方式 。
    

---

## 2. 常见应用模型 🛠️

### A. 步长/模运算分治 (Step-based Division) 🔄

针对形如 $i \equiv y \pmod x$ 的询问 ：

- **小步长 ($x < M$)**：我们要改的数字很多，直接暴力不行，此时维护预处理数组 `tag[x][y]`，记录在该模数下的增量 。
    
- **大步长 ($x \ge M$)**：步长很大，修改或查询的总量是 $O(N/x)$ 级别，直接暴力跳步 。
    

#### 💻 核心实现 (以 CF1207F 为例)

C++

```
const int M = 600; // 阈值，通常取 sqrt(N)
ll a[N];
ll tag[M][M]; // tag[x][y] 表示 mod x 等于 y 的和

void solve() {
    int q;
    cin >> q;
    while (q--) {
        int op;
        cin >> op;
        if (op == 1) { // 修改操作：单点增加 val
            int id, val;
            cin >> id >> val;
            a[id] += val;
            // 预处理：更新所有小步长对应的 tag 数组
            for (int j = 1; j < M; j++) {
                tag[j][id % j] += val;
            }
        } else { // 查询操作：询问所有下标 mod x == y 的值之和
            int x, y;
            cin >> x >> y;
            ll sum = 0;
            if (x >= M) {
                // 大步长：暴力跳步，复杂度 O(N/M)
                for (int i = y; i < N; i += x) sum += a[i];
            } else {
                // 小步长：直接获取 O(1) 预处理结果
                sum = tag[x][y];
            }
            cout << sum << endl;
        }
    }
}
```

### B. 图论中的度数分治 (Vertex Degree Division) 🕸️

- **大点 (Heavy)**：度数 $\ge T$。由于 $\sum deg = 2M$，大点总数不超过 $O(M/T)$ 个 。
    
- **小点 (Light)**：度数 $< T$ 。
    
- **策略**：修改时只更新邻居中的“大点”答案；查询时，小点暴力遍历邻居，大点直接读取预维护结果 。
    

### C. 值的种类分治 (Distinct Value Distribution) 🧩

- **结论**：若若干正整数之和等于 $N$，则其中**不同的取值**最多只有 $O(\sqrt{N})$ 个 。
    
- **补充**：此技巧常用于字符串（长度之和固定）或图论（环长度之和固定）的优化 。
    
