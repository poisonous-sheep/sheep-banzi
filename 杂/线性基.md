# 线性基 (Linear Basis) 学习笔记 🧊

线性基是处理 **异或 (XOR)** 相关问题最强有力的工具之一。它能将一个海量的数据集压缩成一个极小的基底集合，并保持原有的异或特性。

## 1. 核心性质 (Fundamental Properties) ⚖️

* **等效性**：线性基中的元素通过异或可以表示出原集合中所有子集可能产生的异或值。
* **线性无关**：线性基中没有任何非空子集其异或和为 。
* **最简性**：线性基中，每个位置（二进制最高位）最多只对应一个元素。
* **空间压缩**：对于  范围内的数，线性基仅需约  个元素即可。

---

## 2. 基础模板 (Basic Template) 💻

这个模板包含插入、查询最大/最小异或和的功能。

```cpp
#include <vector>
#include <algorithm>

using namespace std;
typedef long long ll;

struct line_basis {
    int B = 60; // 对应 long long 的位数，如果是 int 可以设为 30
    vector<ll> num = vector<ll>(65, 0); // num[i] 存储最高位在第 i 位的基数

    // 插入元素：高斯消元思想
    bool insert(ll x) {
        for (int i = B - 1; i >= 0; i--) {
            if (!(x & (1ll << i))) continue; // 如果 x 的第 i 位为 0，跳过
            
            if (num[i] == 0) { // 如果当前位还没有基数
                num[i] = x;    // 插入并返回成功
                return true;
            }
            x ^= num[i]; // 否则用当前位的基数消去 x 的第 i 位，继续向下找
        }
        return false; // x 被完全消去，说明 x 可以由当前线性基表示（线性相关）
    }

    // 查询与 x 异或后的最小值：贪心策略
    ll qurmin(ll x) {
        for (int i = B - 1; i >= 0; i--) {
            // 如果异或后能变小，就异或（尽量消掉高位的 1）
            x = min(x, x ^ num[i]);
        }
        return x;
    }

    // 查询与 x 异或后的最大值：贪心策略
    ll qurmax(ll x) {
        for (int i = B - 1; i >= 0; i--) {
            // 如果异或后能变大，就异或（尽量让高位变成 1）
            x = max(x, x ^ num[i]);
        }
        return x;
    }
};

```

---

## 3. 进阶应用：第 K 大异或和 🚀

在处理第 K 大/小时，我们需要注意原集合是否能异或出 （即 `insert` 失败的情况）。

### 核心逻辑说明：

1. **重复贡献**：如果原集合有  个数，线性基大小为 ，则每个异或和都会重复出现  次。因此代码中出现了 `k >>= zero` 的逻辑（通常用于处理包含所有子集异或结果的情况）。
2. **二进制拆分**：将线性基重构或直接按位考虑，将  的每一位映射到线性基的每一个“有效基底”上。

```cpp
int main() {
    int n;
    ll k;
    cin >> n >> k;
    
    line_basis T;
    int zero_count = 0; // 记录插入失败的次数
    for (int i = 0; i < n; i++) {
        ll x;
        cin >> x;
        if (!T.insert(x)) zero_count++;
    }

    // 如果考虑所有子集异或和（包括重复产生的），第 K 大需要右移
    // 注意：具体题目对 K 的定义（去重或不去重）可能不同，需灵活调整
    k >>= zero_count; 

    // 提取出所有非 0 的基底
    vector<ll> p;
    for (int i = 0; i < T.B; i++) {
        if (T.num[i] != 0) p.push_back(T.num[i]);
    }

    int m = p.size();
    if (k >= (1ll << m)) {
        cout << -1 << endl; // K 超出范围
        return 0;
    }

    ll ans = 0;
    // 采用从高到低的贪心决策构造第 K 大/小
    for (int i = m - 1; i >= 0; i--) {
        if (k & (1ll << i)) {
            ans = max(ans, ans ^ p[i]); // 选大的分支
        } else {
            ans = min(ans, ans ^ p[i]); // 选小的分支
        }
    }
    cout << ans << endl;
}

```

---

## 4. 重点场景模型总结 💡

### A. 最大异或路径 (Graph XOR)

在图中求  的最大异或路径：

* **定理**：任意路径 = 一条简单路径  若干个环。
* **做法**：DFS 找出所有环的异或值插入线性基，最后用任意一条  路径的权值在里面跑 `qurmax`。

### B. 权值最大线性无关集 (Matroid)

如果每个数带权值，求权值和最大的线性无关子集：

* **贪心策略**：按权值从大到小排序，依次尝试 `insert`。
* **原理**：线性基满足 **拟阵 (Matroid)** 的交换性，贪心即最优。

